import{_ as t,e as o,h as a,o as i}from"./app-BCYcFUMx.js";const s={};function r(d,e){return i(),o("div",null,e[0]||(e[0]=[a('<h1 id="sequence-improvement-sequence-chords" tabindex="-1"><a class="header-anchor" href="#sequence-improvement-sequence-chords"><span>Sequence improvement: sequence chords</span></a></h1><h2 id="preface" tabindex="-1"><a class="header-anchor" href="#preface"><span>Preface</span></a></h2><p>This document is a record of designing/braindumping<br> for the improvement to the sequences feature to add chord support.<br> It is left in an informal and disorganized state<br> — as opposed to a being presentable design doc — out of laziness.<br> Apologies ahead of time if you read this and it&#39;s hard to follow,<br> feel free to contribute a PR to create a new and more polished doc.</p><h2 id="motivation" tabindex="-1"><a class="header-anchor" href="#motivation"><span>Motivation</span></a></h2><p>The desire is to be able to add output chords to a sequence.<br> The effect of this is that: <code>(S-(a b))</code> can be differentiated from <code>(S-a b)</code>.<br> Today, chords are not supported at all.<br> The two sequences above could be written as <code>(lsft a b)</code>;<br> however, the code today has no way to decide the difference<br> between <code>lsft</code> being applied to only <code>a</code> or to both <code>a</code> and <code>b</code>.</p><p>The feature will codenamed &quot;seqchords&quot; for brevity in this document.</p><h2 id="an-exploration-of-an-idea-track-releases" tabindex="-1"><a class="header-anchor" href="#an-exploration-of-an-idea-track-releases"><span>An exploration of an idea: track releases?</span></a></h2><p>Today, the sequence <code>(lsft a b c)</code> doesn&#39;t care when the <code>lsft</code>,<br> or even <code>a</code> or <code>b</code> are released relative to when the subsequent keys<br> are pressed. However, with seqchords, the code could be potentially changed to<br> make sequences release-aware.</p><p>It seems a little difficult to integrate<br> this into the trie structure used to track sequences though.<br> With an implementation that is release-aware,<br> it seems like the code would need to figure out how to conditionally<br> add release events to the trie, depending if the seq was<br><code>(lsft a)</code> or <code>(S-a)</code></p><p>For now, I think a different approach would be better.</p><h2 id="a-different-idea-modify-presses-held-with-mod-keys" tabindex="-1"><a class="header-anchor" href="#a-different-idea-modify-presses-held-with-mod-keys"><span>A different idea: modify presses held with mod keys.</span></a></h2><p>The current sequence type is <code>Vec&lt;u16&gt;</code> since keys don&#39;t fit into <code>u8</code>.<br> However, there are fewer than 1024 (2^10) keys total.<br> That means there are 6 bits to play with.<br> 6 bits are enough for the types of modifiers (of which there are 4),<br> but differentiating both sides (increases to 8).<br> Perhaps one only cares to use both left and right shifts though, and maybe<br> both left and right alts.<br> One could also use a <code>u32</code> instead, but that seems unnecessary for now.<br> I see no backwards compatibility issues if one<br> desired that change in the future.</p><p>With this in mind, while modifiers are held, set the upper unused bits of<br> the stored <code>u16</code> values.</p><h3 id="backwards-compatibility" tabindex="-1"><a class="header-anchor" href="#backwards-compatibility"><span>Backwards compatibility?</span></a></h3><p>This does mean that <code>(lsft a b)</code> behaves differently<br> with vs. without seqchords.<br> Unless maybe the code automatically generates the various permutations<br> of this type of sequence, but that seems complicated.<br> Or maybe have a <code>u16</code> with a special bit pattern that could be used<br> to differentiate between <code>(S-(a b))</code> and <code>(lsft a b)</code>.<br> For now, let&#39;s say that the bit pattern is <code>0xFFFF</code>.<br> If a modifier is pressed and the sequence <code>[..., &lt;mod&gt;, 0xFFFF]</code><br> exists in the trie: continue processing the sequence in mod-aware mode.</p><p>OR for simplicity, just say &quot;screw backwards compatibility&quot; and force users<br> to be clear about what they mean and define the extra permutations, if they<br> want them. I prefer this.</p><h3 id="data-format-examples" tabindex="-1"><a class="header-anchor" href="#data-format-examples"><span>Data format examples</span></a></h3><p>Let&#39;s begin the description of the new data format.<br> Since shifted keys seem like they will be the main use case for seqchords,<br> only that will be described in this document for now.<br> Here are the numerical key values relevant to the examples.</p><ul><li><code>a: 0x001E</code></li><li><code>b: 0x0030</code>.</li><li><code>lsft: 0x002A</code>.</li></ul><p>This differs by OS, but that&#39;s not important.</p><p>The transformation of <code>(lsft a b)</code> to a sequence in the trie today<br> looks like:</p><ul><li><code>[0x002A, 0x001E, 0x0030]</code></li></ul><p>This will remain unchanged with seqchords.<br> Let&#39;s say that chorded keys using <code>lsft</code><br> will have the otherwise-unused MSB (bit 15) set.</p><p>The transformation of some sequences using chords will be:</p><ol><li><code>(S-(a b)) =&gt; [0x802A, 0x801E, 0x8030]</code></li><li><code> (S-a b) =&gt; [0x802A, 0x801E, 0x0030]</code></li><li><code>(S-a S-b) =&gt; [0x802A, 0x801E, 0x802A, 0x8030]</code></li></ol><p>Notably, <code>lsft</code> is modifying its own upper bits.<br> This should simplify the implementation logic<br> so that the code does not need to add a special-case check<br> that the newly-pressed key is itself a modifier.</p><p>One may need to define different sequences if one wishes to use both<br> left and right shifts to be able to trigger these shifted sequences.<br> The syntax does not exist today, but maybe <code>(S-(a b))</code> and <code>(RS-(a b))</code><br> as an example for left and right shifts.<br> The reason different sequences would be required is because the<br> sequence-&gt;trie check operates on the integers that correspond to the keycodes.</p><p>Consideration: maybe there could be transformations for the right modifier<br> keys to ensure they get translated to the left modifier keys.<br> This seems like it could be a sensible default to start with.<br> If a change is desired in the future to <strong>not</strong> do this transformation,<br> it doesn&#39;t seem too difficult to add a configuration item to do so.<br> For now that will be left out, deferring to the YAGNI principle.</p><h3 id="backwards-compatibility-revisited" tabindex="-1"><a class="header-anchor" href="#backwards-compatibility-revisited"><span>Backwards compatibility revisited</span></a></h3><p>Thinking back on the topic of backwards compatibility,<br> I&#39;m scrapping that idea of special bit patterns.<br> I thought of a probably-better way:<br> backtracking with modifier cancellation.</p><p>By default when seqchords gets added,<br> the modified bit patterns will be used<br> to check in the trie for valid sequences.<br> However, with a <code>defcfg</code> item <code>sequence-backtrack-modcancel</code><br> — which should be <code>yes</code> by default for back-compat reasons —<br> if the code encounters an invalid sequence with the modded bit pattern,<br> it will try again with the unmodded bit pattern, and only if that does not<br> match will sequence-mode end with an invalid termination.<br> This backtracking can be turned off if desired,<br> e.g. if it behaves badly in some future seqchords use cases.</p>',31)]))}const c=t(s,[["render",r],["__file","sequence-adding-chords-ideas.html.vue"]]),h=JSON.parse(`{"path":"/sequence-adding-chords-ideas.html","title":"Sequence improvement: sequence chords","lang":"zh-CN","frontmatter":{"description":"Sequence improvement: sequence chords Preface This document is a record of designing/braindumping for the improvement to the sequences feature to add chord support. It is left i...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/kanata/sequence-adding-chords-ideas.html"}],["meta",{"property":"og:site_name","content":"kanata"}],["meta",{"property":"og:title","content":"Sequence improvement: sequence chords"}],["meta",{"property":"og:description","content":"Sequence improvement: sequence chords Preface This document is a record of designing/braindumping for the improvement to the sequences feature to add chord support. It is left i..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Sequence improvement: sequence chords\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/kanata/\\"}]}"]]},"git":{},"readingTime":{"minutes":3.2,"words":959},"filePathRelative":"sequence-adding-chords-ideas.md","excerpt":"\\n<h2>Preface</h2>\\n<p>This document is a record of designing/braindumping<br>\\nfor the improvement to the sequences feature to add chord support.<br>\\nIt is left in an informal and disorganized state<br>\\n— as opposed to a being presentable design doc — out of laziness.<br>\\nApologies ahead of time if you read this and it's hard to follow,<br>\\nfeel free to contribute a PR to create a new and more polished doc.</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"sequence-adding-chords-ideas.md","value":{"title":"sequence-adding-chords-ideas","path":"sequence-adding-chords-ideas.md","outlink":[],"backlink":[]}}],"links":[]}}}`);export{c as comp,h as data};
